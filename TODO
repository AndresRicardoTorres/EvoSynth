============================== generelles ======================================

			!!! Jeden morgen ein paar sachen Dokumentieren !!!
				-->			aktuell ab evolvers			<--

fehlende oder fehlerhafte Testfälle:

	- Selektionen: Float select_count (to_i testcase)
	- EvoSynth::Evolvers::LocalSearch::HillclimberAcceptance
	- EvoSynth::Evolvers::LocalSearch::SimulatedAnnealingAcceptance
	- EvoSynth::Evolvers::LocalSearch::ThresholdAcceptance
	- EvoSynth::Evolvers::LocalSearch::GreatDelugeAcceptance
	- EvoSynth::Evolvers::LocalSearch::RecordToRecordTravelAcceptance
	- EvoSynth::Mutations::SelfAdaptiveGaussMutation


============================== EvoSynth 0.2 ====================================

Features:

	- README:
		=> Quellen irgendwo in der Readme oder in eigener Datei erwähnen (für Algorithmen)
		=> Auf Diplomarbeitshintergrund verweisen

	- EvoBench: Benchmark für Evolutionäre Algorithmen

		=> mehrere Testläufe:
			-> Durchschnittswerte
			-> laufzeit messung der einzelnen Varianten (güte pro minute?)
			-> ergebnisse sollten ein serialisierbares objekt sein

		=> versuchsreihen mit:
			-> array von mutationen, selektionen, rekombination, evolvern, ...
			-> range mit schrittweite für parameter (Integer und Float)
			-> array mit werten für alles andere?

		=> Versuchspläne und Statistiken?!
			-> was ist mit schematheorem und co?
			-> häufigkeiten bestimmter werte an allen positionen eines genomes
			   innerhalb einer population

	- Logger und Exporter:
		=> gnuplot durch eigenes system ersetzen
		=> HTML exporter
		=> gruff exporter entfernen

		=> exporter:
			-> balken für min/max, stddev und fehler
			-> heatmap und 3d topografie plots

============================== EvoSynth 0.3 ====================================

Features:

	- ist anstatt OrderedRecombination OrderRecombination korrekt?

	- child_factor durch mü und lambda ersetzen und als feste zahl anstatt faktor

	- Evolver sollte Observer vom Profile sein, um auf dessen Änderungen reagieren zu können

	- Species-Konzept sinnvoll? (siehe ECJ)

	- metaprogramming sachen durch "dynamisch geerbte" mixins ersetzen

	- nicht reelwertige Fitnesswerte:
		=> Fitness als Objekt mit Vergleichsoperatoren (siehe OpenBEAGLE, ECJ)
		=> Insgesamt fehlt da nicht viel, aber zum Beispiel braucht die
		   Fitnessproportionale Selektion floats (einfach nach ".fitness" suchen)

	- externe (nicht-Ruby) fitness-funktionen aufrufen

	- Selektionen:
		=> Fitnessproportionale & Roulette-Wheel-Selektion nach dem Vorbild von EO
		   Refaktorisieren (siehe eoRanking

	- Algorithmen:
		=> CMBCoevolutionary braucht ein Refactoring
		=> die koevolutionären könnten sich etwas von ECJ (CompetitiveEvaluator) abgucken

	- Checkpointing für Evolver:
		=> Save, Stop, Restart, Continue
		=> eventuell mit Logger verknüppern
		=> verschiedene Bedingungen, alá EO:
			-> generationen, steady state, ...
			-> verschiende bedingungen nacheinander ODER parallel!

	- Standardinitialisierer:
		=> Factory für häufig verwendete Individuen (siehe examples -> immer dasselbe)

============================== EvoSynth >=0.3 ===================================

Features:

	- add # encoding: utf-8 to all ruby files
	- was ist mit http://rubygems.rubyforge.org/rdoc/Gem/Security.html ?

	- Super-Gene und Allele -> eventuell auch für statistiken erfassen

	- TSP und GraphColouring Problem generischer machen und refactorisieren

	- Logger:
		=> DatabaseLogger wäre fein! könnte dann für Datamining genutzt werden ;-)
		=> logger sollte auch bei fitnessänderungen (der population?) getriggert werden können,
		   das geht aber vielleicht eher in richtung eventsystem

	- Exporter:
		=> SVG output
		=> database exporter (mysql fürs erste?) ( != databaselogger )

	- Benchmarkfunktionen:
		=> real benchmark functions - siehe neu gefundenes paper
		=> Matrix Multiplikationsproblem aus Paredis Paper (epistasis gut steuerbar)
		=> C-Funktion (Weicker page 272)
		=> sämtliche mit Randbedingungen (Weicker page 274)

	- Decoder/Encoder:
		=> RealToBinary, IntegerToBinary, BinaryToInteger

	- Algorithmen:
		=> Tabu-Suche am beispiel graph colouring (Weicker page 164)
		=> Schwärme
		=> neuronale Netze (gibts da ein gem für)

		=> Evolutionäres Programmieren & Genetisches Programmieren (Weicker page 139--154)
			-> Gentische Programmierung (Ruby programme wären schön)
			-> rubytree gem nutzen: http://rubytree.rubyforge.org/rdoc/index.html

		=> Mehrzieloptimierung:
			-> NSGA selektion (204)
			-> SPEA2, PAES (205,206)
			-> wenigstens ein Beispiel zur Mehrzieloptimierung

		=> Meta-Evolver (eventuell mittels metaprogramming alá Elistismus):
			=> was ist mit hall-of-fame oder ähnlichem?
			=> was ist mit alternden Individuuen? Vielleicht ein AgeMixin?

		=> Mehrpopulationsprobleme & Koevolutionäres:
			=> was ist da noch sinnvoll? inseln & migration?

	- BinaryGenome mittels inline C optimieren

	- Codegenerator System (z.b. für OpenBEALE und EO) -> siehe fehler!

	- Bootstrap zeugs, inspiriert von OpenBEAGLE (initializer)
		=> braucht man das wirklich?
		=> Breeder klingt am besten (siehe ECJ)
		=> variable anzahl an eltern, kindern für recombinationen (siehe EO paper)