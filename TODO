Features:
	- RunnableAlgortihm (run_until) geschickt mit FitnessCalculator koppeln,
	um nur eine bestimmt "evaluierungsanzahl" zu rennen
	- CCGA example überarbeiten und eventuell toolklassen extrahieren
	- EvoSynth:Util überarbeiten
	- nicht reelwertige Fitnesswerte?! Da fehlt nicht viel, aber zum Beispiel
	die Fitnessproportionale Selektion braucht die (einfach nach ".fitness" suchen)

	- CombinedMutation zu ProportionalCombinedMutation umbenennen
	- SequentiallyCombinedMutation erstellen (alle nacheinander)
	- analog dazu combined rekombinationen erstellen
	- ist sowas bei selektionen nützlich? eher nicht!

	- variable anzahl an eltern, kindern für recombinationen (siehe EO paper)

Fehler:
	- GaussMutation: die normalverteilung stimmt noch überhaupt nicht! (Seite 281)

Testfälle:
	- EvoSynth::Algorithms::LocalSearch::HillclimberAcceptance
	- EvoSynth::Algorithms::LocalSearch::SimulatedAnnealingAcceptance
	- EvoSynth::Algorithms::LocalSearch::ThresholdAcceptance
	- EvoSynth::Algorithms::LocalSearch::GreatDelugeAcceptance
	- EvoSynth::Algorithms::LocalSearch::RecordToRecordTravelAcceptance

Algorithmen:
	- DERANDOMISIERTE-ES (Weicker page 139)
	- Evolutionäres Programmieren & Genetisches Programmieren (Weicker page 139--154)
	- reichlich grob formuliert:  EA-SCHEMA (Weicker page 39)
	- eher als beispiel geeignet: EA-HANDLUNGSREISENDENPROBLEM (Weicker page 31)
	- was ist mit pheno/genetyp? reichen decoder oder sollte explizite unterscheidung gemacht werden?

Benchmarkfunktionen:
	- Einsenzählproblem (Weicker page 272)
	- Royal-Road (Weicker page 272)
	- C-Funktion (Weicker page 272)
	- sämtliche mit Randbedingungen (Weicker page 274)

Decoder/Encoder:
	- RealToBinary

EvoBench: Benchmark für Evolutionäre Algorithmen
	- mutationen, selektionen und co
	- diversität und co