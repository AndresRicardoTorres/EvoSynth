Was sind zwingend umzusetzen, um mal ein 0.1 Release mit allem pipapo zu machen?!

Features:
	- RunnableAlgortihm (run_until) geschickt mit FitnessCalculator koppeln,
	um nur eine bestimmt "evaluierungsanzahl" zu rennen
		=> lohnt sich dafür ein Termination Operator oder ist ein lambda ausdruck
		   ausreichend

	- EvoSynth in Vector, Permutation, ES und GP auftrennen, gibts da sinnvollere sachen?

	- CCGA example überarbeiten und eventuell toolklassen extrahieren

	- nicht reelwertige Fitnesswerte?! Da fehlt nicht viel, aber zum Beispiel
	die Fitnessproportionale Selektion braucht die (einfach nach ".fitness" suchen)

	- BinaryGenome mittels inline C optimieren

	- CombinedMutation zu ProportionalCombinedMutation umbenennen
	- SequentiallyCombinedMutation erstellen (alle nacheinander)
	- analog dazu combined rekombinationen erstellen
	- ist sowas bei selektionen nützlich? eher nicht!
		=> vielleicht CombinedOperator erstellen? (method_missing magie!)
		=> was ist mit einem if-then-else CombinedOperator wie in OpenBEAGLE?
		=> bei diesen generischen combined operatoren ist das problem der default
		   rückgabewert! (was wenn keine operation genutzt wird)

	- variable anzahl an eltern, kindern für recombinationen (siehe EO paper)

	- weak und strong elistism (elitären GA überarbeiten)
		=> schönen elitären meta-algorithmus als überbau für alle algorithmen

	- Bootstrap zeugs, inspiriert von OpenBEAGLE (initializer)
		=> Breeder klingt am besten (siehe ECJ)

	- EvoSynth modul struktur überarbeiten!
		=> Algorithm zu Evolver umbenennen? scheint gebräuchlich zu sein
		=> Operationen je nach Repräsentation gruppieren
		=> EvoSynth:Util überarbeiten
		=> FitnessCalculator zu Evaluator umbenennen

	- Randomizer (normal und gaussverteilt) - als Singleton oder nicht?
		=> einstellbarer seed, für reproduzierbare Evolutionsläufe

	- OpenBEAGLE hat ein relativ interessantes Operator Konzept:
		=> siehe: http://beagle.gel.ulaval.ca/refmanual/beagle/html/df/d5a/group__Op.html

	- Codegenerator System (z.b. für OpenBEALE und EO) -> siehe fehler!

	- Checkpointing, Save, Stop, Restart, Continue
		=> eventuell mit Logger verknüppern


Fehler:
	- GaussMutation: die normalverteilung stimmt noch überhaupt nicht! (Seite 281)
		=> eigenen Randomizer schreiben?! eher nicht!
	- ES überarbeiten und glatt ziehen
	- ES: mü+lambda und mu,lambda klären!

Testfälle:
	- EvoSynth::Algorithms::LocalSearch::HillclimberAcceptance
	- EvoSynth::Algorithms::LocalSearch::SimulatedAnnealingAcceptance
	- EvoSynth::Algorithms::LocalSearch::ThresholdAcceptance
	- EvoSynth::Algorithms::LocalSearch::GreatDelugeAcceptance
	- EvoSynth::Algorithms::LocalSearch::RecordToRecordTravelAcceptance

Algorithmen:
	- Mehrzieloptimierung
	- Gentische Programmierung (Ruby programme wäre geil!)
	- DERANDOMISIERTE-ES (Weicker page 139)
	- Evolutionäres Programmieren & Genetisches Programmieren (Weicker page 139--154)
	- reichlich grob formuliert:  EA-SCHEMA (Weicker page 39)
	- eher als beispiel geeignet: EA-HANDLUNGSREISENDENPROBLEM (Weicker page 31)
	- was ist mit pheno/genetyp? reichen decoder oder sollte explizite unterscheidung gemacht werden?

Benchmarkfunktionen:
	- Einsenzählproblem (Weicker page 272)
	- Royal-Road (Weicker page 272)
	- C-Funktion (Weicker page 272)
	- sämtliche mit Randbedingungen (Weicker page 274)

Decoder/Encoder:
	- RealToBinary

EvoBench: Benchmark für Evolutionäre Algorithmen
	- mutationen, selektionen und co
	- diversität und co